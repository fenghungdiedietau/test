Fit

fit :: Int -> [a] -> Pattern Int -> Pattern a
The fit function takes a pattern of integer numbers,
which are used to select values from the given list.
What makes this a bit strange is that only a given
number of values are selected each cycle. For example:

cps(120/60/4)

d1 $ sound (fit 3 ["bd", "sn", "arpy", "arpy:1", "casio"] "0 [~ 1] 2 1")

--
固定結構中 "0 [~ 1] 2 1"
置入不同採樣"bd", "sn", "arpy", "arpy:1", "casio"
由fit n 指定數字與採樣的對映
--

d1 silence

The above fits three samples into the pattern,
i.e. for the first cycle this will be "bd", "sn" and "arpy",
giving the result "bd [~ sn] arpy sn" (note that we start counting at zero,
  so that 0 picks the first value).
  The following cycle the next three values in the list will be picked,
  i.e. "arpy:1", "casio" and "bd", giving the pattern
  "arpy:1 [~ casio] bd casio" (note that the list wraps round here).

fit' :: Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a
fit' is a generalization of fit, where the list is instead constructed
by using another integer pattern to slice up a given pattern.
The first argument is the number of cycles of that latter pattern
to use when slicing. It’s easier to understand this with a few examples:


d1
$ every 2 (# gain 0)
$ sound (fit' 1 3 "0 1 2" "1 0 1 [~ 2]" "bd arpy cp")


bd 0, arpy 1, cp 2
"1 0 1 [~ 2]" ==> "arpy bd arpy [~ cp]"

The first 1 just tells it to slice up a single cycle of "bd sn".
The 2 tells it to select two values each cycle,
just like the first argument to fit.
The next pattern "0 1" is the “from” pattern which tells it how to slice
, which in this case means "0" maps to "bd", and "1" maps to "sn".
  The next pattern "1 0" is the “to” pattern, which tells it how to rearrange
  those slices. So the final result is the pattern "sn bd".

A more useful example might be something like

bps(60/120)

d1 $ fit' 1 4 (run 4) "0 1 3 2"
   $ chop 4 $ (sound "breaks152" # unit "c")

hush

d1
  $ jux (slow 3)
  $ sometimes ((swingBy (3/2) 8).(degradeBy 0))
  $ fit' 1 16 (run 16) (efull 3 8 "10 6" (slow 16 (run 16)))
  $ chop 16 $ (sound "breaks152")
  # cut 1
  -- # speed "0.8"
  -- # n (slow 12 (scale 0 10 $ sine1))

{-|which uses chop to break a single sample into individual pieces,
which fit' then puts into a list (using the run 4 pattern) and
reassembles according to the complicated integer pattern.
-}


d1 silence

which uses chop to break a single sample into individual pieces,
which fit' then puts into a list (using the run 4 pattern) and
reassembles according to the complicated integer pattern.


-- {-|
fit' :: Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a
fit' is a generalization of fit, where the list is instead constructed by using another
integer pattern to slice up a given pattern.
The first argument is the number of cycles of that latter pattern to use when slicing.
It’s easier to understand this with a few examples:


d1
$ slow 2
$ sound (fit' 1 2 "1 2 0" "1 1 1 [0 1] 1 2" "bd sn cp")

hush

d2 $ sound "cp"

So what does this do? The first 1 just tells it to slice up a single cycle of "bd sn".
The 2 tells it to select two values each cycle, just like the first argument to fit.
The next pattern "0 1" is the “from” pattern which tells it how to slice,
which in this case means "0" maps to "bd", and "1" maps to "sn". The next pattern "1 0" is the “to” pattern, which tells it how to rearrange those slices. So the final result is the pattern "sn bd".

A more useful example might be something like

d1 $ fit' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" $ chop 4 $ (sound "breaks152" # unit "c")

which uses chop to break a single sample into individual pieces, which fit' then puts into a list (using the run 4 pattern) and reassembles according to the complicated integer pattern.

hush

bps (35/120)

d2 $ s "cp"

d1
  $ (378 ~>)
 -- $ slow 8
 $ jux (|+| n (iter 3 $ run 3))
 $ fit' 1 16 (run 16) "[0,1..20]"
 -- $ every 4 (|+|speed 2)
 $ chop 16 $ sound "[tt]"
 # n (slow 69 (run 68))
 -- # lpf (slow (choose [1,1.5..10]) $ discretise 50 (scale 400 3200 $ sine1))
 # cut "0"
 # attack 0.07
 -- # release 2
 -- # nudge (fast 4 $ choose [0.9,1.1..1.3])

hush

d1 silence

d3
-- $ slow 8
-- $ every 4 (|+|speed 2)
-- $ striate 16
$ fit' 1 16 (run 16) "[0,1..15]"
$ sound "dna"
# cut "1"
