-- {-|
fit' :: Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a
fit' is a generalization of fit, where the list is instead constructed by using another
integer pattern to slice up a given pattern.
The first argument is the number of cycles of that latter pattern to use when slicing.
It’s easier to understand this with a few examples:


d1
$ slow 1
$ sound (fit' 1 2 "1 2 0" "1 1 1 [0 1] 1 2" "bd sn cp")

hush
d2 $ sound "cp"

So what does this do? The first 1 just tells it to slice up a single cycle of "bd sn".
The 2 tells it to select two values each cycle, just like the first argument to fit.
The next pattern "0 1" is the “from” pattern which tells it how to slice,
which in this case means "0" maps to "bd", and "1" maps to "sn". The next pattern "1 0" is the “to” pattern, which tells it how to rearrange those slices. So the final result is the pattern "sn bd".

A more useful example might be something like

d1 $ fit' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" $ chop 4 $ (sound "breaks152" # unit "c")
which uses chop to break a single sample into individual pieces, which fit' then puts into a list (using the run 4 pattern) and reassembles according to the complicated integer pattern.

hush

bps (35/120)

d2 $ s "cp"

d1
 -- $ slow 8
 $ jux (|+| n (iter 3 $ run 3))
 $ fit' 1 16 (run 16) "[0,1..20]"
 -- $ every 4 (|+|speed 2)
 $ chop 16 $ sound "[like4*4]"
 # n (run 3)
 # lpf (slow (choose [1,1.5..10]) $ discretise 50 (scale 400 3200 $ sine1))
 # cut "0"
 # attack 0.07
 -- # release 2
 -- # nudge (fast 4 $ choose [0.9,1.1..1.3])

hush

d1 silence

d3
-- $ slow 8
-- $ every 4 (|+|speed 2)
-- $ striate 16
$ fit' 1 16 (run 16) "[0,1..15]"
$ sound "dna"
# cut "1"
