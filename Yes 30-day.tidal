--day 01 2018/12/24

hush

do
let
  a= "[[yes [bd:5 yes] [yes*2]]*[1 [1.25 [1 <1 5>]] <1 3> <3.3 1 2>]*<1.5 2>]"
  b= "[[tt4b [bd:5 tt4b] [tt4b*2]]*[1 [1.25 [1 <5>]]  <3.3 1 2>]*<1.5 2>]"
d1
   $ off 0.5 (
   (# begin (segment "24" $ range 0 1  $ saw ))
   .(# accelerate 0.12)
   .(# room (segment 24 $ range 0.4 0.9 $ rand))
   .(# cutoff (slow 12 $ segment 24 $ range 1500 5000 $ saw))
   )
   -- $ brak
   $ sound b
   |+ n (slow 136 $ run 136)
   -- |+ n (segment (range 1 30 $ (cT 1 "12")) $ range 0 1 $ saw )
   -- |+ n "100"
   # cut 1
   # release (slow 4 $ segment 64 $ range 4 10 $ saw )

   hush

--day 02 2018/12/25 radio , with MIDI controls
d3
  -- $ almostNever ( (off 1 (|+ n (slow 136 $ run 136)))
  -- .(# sound "[[yes*5 [bd*4 yes] sn yes]*[[1] [1.25 [5]] 2 3]*2]")
  -- .(|+ release "10")
  -- .(#cut "0 0 1")
  -- )
  $ every 3 (within (0.75,1.3) ((# gain "0.5" )
  .(# cutoff (slow 20 $ segment 20 $ range 200 3000 $ sine))
  .(density 1.25)
  .(stut' 15 (range 0 2 $ (cT 0.25 "12")) (# speed "0.5"))))
  -- $ every 5 (within (0,0.75) $ juxBy 0.1 (|+ n (segment 40 $ range 1 10 $ sine )))
  -- $ off 1 ((juxBy 1 (+n "1")).(# begin (segment 40 $ range 1 0 $ sine )).rev)
  $ sound "[[yes*5 [bd*4 yes] yes]*[[1] [1.25 [5]] 2 3.3]*2]"
  -- |+| n (segment 30 $ range 1 12 $ saw )
  -- |+ n "[16]"
  |+ n (slow 136 $ run 136)--(cF 1 "15"))
  -- # n "2"
  # begin (segment "<24>" $ range 0 (cF 1 "13") $ saw )
  -- # cut 1
  -- # hold "1.3"
  -- # release (slow 20 $ segment 40 $ range 0.3 1 $ saw )
 |+ release (slow 9 $ segment 10 $ range 0.5 (range 0 5 $ (cF 5 "14")) $ sine )
  -- # attack (slow 200 $ segment 200 $ range 0.14 0.175 $ saw )

  hush

--day 3 **spread + striate**
d1
  $ almostNever (loopAt 4)
  -- $ slowspread (slow) [164,128,240,300]
  $ jux (|+| speed (segment (choose [16,1,32]) $ range 0.5 1.2 $ density 0.15 sine))
  $ (spread (striate' 200) [(10/24), (1/30), (1/20), (15/20) , (10/20)] $ sound "yes" )
 |+| speed (slow 100 $ segment 100 $ range 0.2 1 $ sine)
  + n (slow 136 $ run 136)

hush


  d1
  $ loopAt 1
  $ sound"yes"
  |+ n (slow 10000 $run 10000)

  hush
  -- $ loopAt (choose [1,2])
  -- $ sound (slow 10 $ choose ["yes","bev"])


problem task:怎麼自動置換sample set??


do
  let a = (choose[1,2,0.5])
  let b = (choose["yes","sn","bd","cp"])
  d1
  $ loopAt a
  $ sound (b)
  # n (slow 10000 $run 10000)

do
let a = segment 1 $ choose ["bd","yes"]
d1 $ sound a

do
  let a = slow 138 $ segment 1 $ choose ["yes","tt4b"]
  d1
    $ loopAt 1
    $ sound a
    + n (slow 138 (run 138))

hush
--day4

d1
   -- some effects
   -- $ degradeBy 0.1
   -- $ every 3 (+ n (slow (range 0.75 2 $ cT 1 "13" )  $ segment 13 (irand 2)))
   $ every 4 (within (0.75,1) (fast 0.75 . (# speed "-1")))
   $ every 5 (within (0,0.15)((+ accelerate ((sine))).(rev)))
   ----random picking n samples in sample folder every (1/16)cycles
   $ loopAt 1
   $ sound "[breaks125,tt4b]"
   -- + n (slow (choose [1,2,3,5]) $ segment 16 (irand 4))
   + n (slow 114 $ run 114)
   + n "28"
   + begin (slow (range 0.05 5 $ cT 2.5 "12" ) $  segment 16 (saw))
   -- + cut "[1 0 [1 0] 0 1 [0 1]]"
   + unit "[c r]%10"
   + unit "[c r ]%10"
   --sample playing lengths
   # cut "0"
   -- |+ release (segment 16 (choose [1,0.75,1.25]))
   |+ release (range 0.0075 6 $ cF 1 "13" )
   # gain "1.3"

once $ s "momo" # gain "1.2" + n (irand 1)

  hush

d4 $ spaceOut [1.8,0.3,0.6]
   -- $ s "[bd*4,cp]"
   $ sound (fit 2 ["bd", "bd", "cp", "bd" , "bd"] "[0*6,1]")
   -- # cps (iter 10 (segment 12 $ run 1))

hush

--day05 try ur
let pats =
      [
        ("a",
          -- $ almostNever ( (off 1 (|+ n (slow 136 $ run 136)))
          -- .(# sound "[[yes*5 [bd*4 yes] sn yes]*[[1] [1.25 [5]] 2 3]*2]")
          -- .(|+ release "10")
          -- .(#cut "0 0 1")
          -- )
           every 3 (within (0.75,1.3) ((# gain "0.5" )
          .(# cutoff (slow 20 $ segment 20 $ range 200 3000 $ sine))
          .(density 1.25)
          .(stut' 15 (range 0 2 $ (cT 0.25 "12")) (# speed "0.5"))))
          -- $ every 5 (within (0,0.75) $ juxBy 0.1 (|+ n (segment 40 $ range 1 10 $ sine )))
          -- $ off 1 ((juxBy 1 (+n "1")).(# begin (segment 40 $ range 1 0 $ sine )).rev)
          $ sound "[[yes*5 [bd*4 yes] yes]*[[1] [1.25 [5]] 2 3.3]*2]"
          -- |+| n (segment 30 $ range 1 12 $ saw )
          -- |+ n "[16]"
          |+ n (slow 136 $ run 136)--(cF 1 "15"))
          -- # n "2"
          # begin (segment "<24>" $ range 0 (cF 1 "13") $ saw )
          -- # cut 1
          -- # hold "1.3"
          -- # release (slow 20 $ segment 40 $ range 0.3 1 $ saw )
         |+ release (slow 9 $ segment 10 $ range 0.5 (range 0 5 $ (cF 5 "14")) $ sine )
         ),
        ("b", almostNever (loopAt 4)
        -- $ slowspread (slow) [164,128,240,300]
        $ jux (|+| speed (segment (choose [16,1,32]) $ range 0.5 1.2 $ density 0.15 sine))
        $ (spread (striate' 200) [(10/24), (1/30), (1/20), (15/20) , (10/20)] $ sound "yes" )
       |+| speed (slow 100 $ segment 100 $ range 0.2 1.2 $ sine)
        + n (slow 136 $ run 136)
        ),
        ("c",
          every 4 (within (0.75,1) (fast 0.75 . (# speed "-1")))
        $ every 5 (within (0,0.15)((+ accelerate ((sine))).(rev)))
        ----random picking n samples in sample folder every (1/16)cycles
        $ loopAt 1
        $ sound "[breaks125,tt4b]"
        + n (slow (choose [1,2,3,5]) $ segment 16 (irand 4))
        + n (slow 114 $ run 114)
        -- + n "28"
        + begin (slow (range 0.05 5 $ cT 1 "12" ) $  segment 16 (saw))
        -- + cut "[1 0 [1 0] 0 1 [0 1]]"
        -- + unit "[c r]%10"
        --sample playing lengths
        # cut "0"
        |+ release (segment 16 (choose [1,0.75,1.25]))
        # gain "1.3"
        ),
        ("d",
            loopAt 1
            $ sound (segment 1 $ choose ["yes","tt4b","dtna4b"])
            + n (slow 138 (run 138))
        )
      ]
    fx = [("reverse", (# (room 0.8 # sz 0.99 # orbit 1))),
          ("n", (+ n (slow 138 (run 138))))
         ]
in
d1 $ ur 138 (segment 1 (choose["d:n","a","b","c"])) pats fx
--d1 $ ur 120 "a b:reverb c:faster" pats fx

hush


---day 6

d1
  -- $ slow 2
  $ degradeBy 0.6
  $ loopAt 1
  $ sound"yes"
  + begin (fast 1 $ smooth $ segment 16 $ range 0 1 $saw)
  + gain (fast 1 $ smooth $ segment 16 $ range 0.4 1 $saw)
  # release 0.045
  -- # hold 0.05
  + release ((iter 16) (smooth "[0.2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]"))
  + pan "[1 0]/2"
  + n (slow 136 (run 136))

  d2
    -- $ slow 2
    $ (0.10 ~>)
    $ loopAt 1
    $ sound"yes:11"
    + begin (fast 1 $ smooth $ segment 16 $ range 0 1 $saw)
    + gain (fast 1 $ smooth $ segment 16 $ range 0.3 0.9 $saw)
    + accelerate (fast 1 $ smooth $ segment 16 $ range 0 (-0.8) $saw)
    # release 0.2
    + pan "[0.3 0.7]/2"
    # hold 0.2
    + hold ((iter 16) (smooth "[ 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0]"))
    + n (slow 136 (run 136))


d1 $ sound "{bd ~}%16"

d2 $ sound "sn"


  hush

--day 07

xfade "yes"
 -- $ juxBy ((slow 5 $ segment 8 $ range 0 1 $ saw)) (chop 10)
  -- $ chop (round <$> (slow 4 $ smooth $ segment 16 $ range 20 40 $ sine))
  -- $ juxBy 0.8 ((chop (round <$> (smooth $ segment 15 $ range 1 7  $ saw))).rev.
  --              (slow "<1 1.2 3>")
  --             )
  -- $ off 1 ((struct (every 2 ((slow 2).inv )"[t [t [t f]] ~ t]") ).(# speed 2).(# room 0.9).(# size 0.5))
  $ sound "yes"
  -- # cut 1
  + begin (slow 7 $ smooth $ segment 16 $ range 0 1 $saw)
  + release (slow 5 $ smooth $ segment 8 $ range 0.125 0.4 $ saw)
  + lpf (slow 16 $ smooth $ segment 14 $ range 800 3500 $ saw)
  + cps (slow 11 $ smooth $ segment 32 $ range 1 10 $ sine)
  + n (slow (136*6) $ run 136)

hush



--day 08

:t weave

hush

d1 $ weave 12 ((pan (range 0.2 0.8 $ sine)))
                   [
                    struct (every "<4>" (slow 1.5) "[[t f <f t>][t f f] t  [t [f t]]]") $
                    sound "tt4b"
                    + begin
                    (
                      -- slow 6 $
                      -- slow "<6.7 7.8 8.9 9.9 3.5 20>" $
                      smooth $ segment 16 $ range 0 1 $saw)
                    +  release (slow 5.08  $ smooth $ segment 8 $ range 0.125 0.9 $ saw)
                    +| release ((0.125 <~) $ slow 5 $ smooth $ segment 16 $ range 0.125 0.5 $ saw)
                    -- *| release ((0.130 <~)  $ slow 20.05 $ smooth $ segment 20 $ range 0.5 4 $ saw)
                    + lpf (slow 16 $ smooth $ segment 14 $ range 2500 4500 $ saw)
                    -- + room (slow 10 $ segment 12 (choose [0.8,0,1.2]))
                    -- # size 0.3
                    ,
                     (0.04<~)
                     $ sound "momo"
                     + begin (slow 7 $ smooth $ segment 16 $ range 0 1 $saw)
                     + release (slow 5.08 $ smooth $ segment 8 $ range 0.125 0.9 $ saw)
                     +| release ((0.125 <~) $slow 5 $ smooth $ segment 16 $ range 0.5 0.4 $ saw)
                     *| release ((0.25 <~) $slow 5.05 $ smooth $ segment 20 $ range 0.5 1 $ saw)
                     + lpf (slow 16 $ smooth $ segment 14 $ range 800 6500 $ saw)
                     # gain 0
                    ]
    # n (slow (1000*1) $ run 1000)



hush

-- day 09 --start from this
d1 $ loopAt 8 $ rev $ linger 0.5 $ chop 64 $ sound "bev"

d1 $ loopAt 8 $ rev
   $ linger ((slow 8 $ smooth $ segment 1 $ range 0.5 1 $ saw))
   $ chop 64 $ sound "bev"


d1
   -- $ loopAt ((slow 8 $ smooth $ segment 1 $ range 1.02 1 $ saw))
   $ rev
   $ chop 36
   -- $ linger ((slow 4  $ segment 3 $ range 0.5 1 $ saw))
--   "[<0.25 1 1 [1 0.25]>]"
   -- $ stuck [
   --          linger "[0.25]",
   --          linger "1"
   --          ]
   -- $ stut 3 0.5 1
   $ sound "yes:134"
   - n (slow (136*1) $ run 136)
   + begin (slow 1 $ segment 16 $ range 0.05 1 $ saw)
   -- # attack 0.06
   # cut 1

hush

-----*solve the gap when n change*-----

let a = (slow 12 $ segment 72 $ range 20 35 $ saw)
in
d1
  -- $ degradeBy 0.1
  $ loopAt 1
  $ off 0.125 (
            (rev).
            (+ speed "1").
            (+ n "1 2").
            (+ pan "0.2 0.8").
            (+ begin  (slow  (a*2) $ segment 16 $ range 0.01 0.99 $ saw)).
            (+ release (slow (1/a) $ segment 16 $ range 0.125 6 $ saw)).
            (+ gain (slow (a*3) $ segment 16 $ range 0.5 1 $ sine))
            )
  $ chop (round <$> a)
  $ sound "[tt4b:0]"
  + begin  (slow (a) $ segment a $ range 0.01 0.99 $ saw)
  + attack (slow (a) $ segment a $ range 0.5 1 $ saw)
  + n (slow (136) (run 136 ))
  -- + cut 1
  -- = gain "0.4"

  hush



  hush
