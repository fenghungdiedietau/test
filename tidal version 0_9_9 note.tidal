cps 0.8

d2
  $ sometimes ((swingBy (3/2) 12).(degradeBy 0))
  $ s (iter 8 (efull 3 8 "bd cp" "bass"))
  # n (slow 12 (scale 0 10 $ sine1))
  # gain 1

    hush

--Sequence parser
Now you can give * and / subpatterns in the parser.
For example "[a b]*[2 3]" would be the same as "[a b] [b a b]"
(i.e. the first half of "a b a b",
which is the pattern at twice the speed,
and the second half of "a b a b b a b",
which is the pattern at three times the speed).

d2 $ sound "[[bd sn]*[2 3]]"

would be the same as

d2 $ sound "[bd sn] [sn bd sn]"

d2 $ sound "[[bd sn]/[2 3],[bd cp]*[2 3]]"

hush

  -- "x ~ ~ x ~ ~ x ~"

----------distrib-----------
d1
  $ distrib [(round <$> (slow 18 $ segment 18 $ range 1 3 $ sine)),(round <$> (slow 5 $ segment 16 $ range 5 8 $ sine)),17]
  $ sound "[bd]*4"
  -- # gain (efull 3 16 "1" "2")
  -- # nudge (range 0 2 $ slow 16 $ sine)
  -- # orbit 1
  -- # release 1
  -- # begin (slow 10 (range 0.1 0.99 $ sine))
  -- # cut 1

d2
    $ distrib [(round <$> (slow 18 $ segment 18 $ range 1 4 $ saw)),(round <$> (slow 10 $ segment 16 $ range 5 20 $ sine)),17]
    $ sound "[sn]*2"

:t distrib
